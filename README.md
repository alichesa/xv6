# xv6  +  mysql
- QEMU允许用户在系统上面运行另外一个虚拟系统
- fork调用一次是返回两次，对于父进程是返回子进程的pid，对于子进程是返回0。fork的子进程的描述符会继承父进程的
- exec是从指定的可执行文件中加载程序并替换当前进程的内存镜像，将当前进程的代码和数据替换为另一个程序的内容
- 利用fork和exec可以实现I/O的重定向，因为fork是创建进程，可以先使用close关闭当前的IO，再open文档定义到文档，再使用exec进行替换
- 使用fork和dup可以实现文件的偏移共享
- 管道有两个口，分别用于接收和发送，一个进程可以有多个管道进行通信
- 一个系统中的文件描述符是有限的，fork不仅会创建子进程，还会将父进程的文件描述符传递给子进程
- pipe(fd[2])这就是给当前进程返回两个文件描述符分别指向pipe
- 如果父进程有一个pipe，然后fork了一个子进程，此时的子进程是拥有父进程的pipe副本的，这管道是相通的，可以直接进行通信，这时候就需要关闭某个口才不会出现管道堵塞的问题
- 每个进程都有自己单独的页表
- 内核地址和用户地址是在同一地址空间，只不过有权限隔离，这样方便用户态和内核态的切换。用户态和内核态都有自己的线程，态的切换就是线程是否被挂起
- PC 开机 → 加载 boot loader → boot loader 加载 xv6 内核 → 内核开始运行
- 每个线程都有自己的context，这里面包含了线程结构体的所有信息（寄存器等）
- 创建一个进程： 建页表 → 分内存 → 映射地址 → 拷程序 → 设寄存器 → 就绪调度
- 运行一个进程： 进入调度器 → 找到 RUNNABLE 进程 → 切换到内核线程上下文 → forkret 初始化 → trapret 切换到用户态
- 运行exec：    第一个用户进程（initcode.S）一启动就执行 exec("/init", argv)，用 /init 替代自己，从而启动 shell 等服务，建立用户空间。
- 文件描述符一般是0读1写
- 操作系统就是用来隔离硬件和程序的
- 如果没有操作系统的话，那么就不存在进程的区别，那么都作用于同一片内存，就会容易发生覆盖。操作系统内核会完成不同进程在CPU上的切换

# 硬件
- 半双工是发送器与接收器之间只有一根总线相连接，而全双工是两条总线相连接
- URAT通信协议的中文名称通常为 ​​“通用异步收发传输器”​​（Universal Asynchronous Receiver/Transmitter）。起始-数据-校验-结束
<img width="697" height="250" alt="image" src="https://github.com/user-attachments/assets/42bb30a4-d993-4185-b1f7-f88e2cdcf037" />
- 波特率来进行区分，比如波特率为1，每秒发送1位，那么接收方一秒接收到‘0’，发送的就是01；如果两秒接收到‘0’，那么发送的就是0011
- I2C 使用两条线在主控制器和从机之间进行数据通信，I2C 是支持多从机的，也就是一个 I2C 控制器下可以挂多个 I2C 从设备
<img width="861" height="311" alt="image" src="https://github.com/user-attachments/assets/f17a419d-d770-4af9-85b5-f734d9488135" /> 
- I2C起始位 -- 时钟为高，数据为低  I2C停止位 -- 时钟和数据都是高
- I2C 总线在数据传输的时候要保证在 SCL 高电平期间， SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生
<img width="951" height="282" alt="image" src="https://github.com/user-attachments/assets/4a8af527-7422-4f21-9e22-9280b5c2583d" />
<img width="956" height="344" alt="image" src="https://github.com/user-attachments/assets/e48e6e80-9177-47b0-aa7f-fc7079c32fc3" />
​​SPI​​：高速、全双工，适合 Flash、ADC 等，但硬件复杂。
​​UART​​：简单、点对点，适合调试，但需固定波特率。
​​I2C​​：多设备共享、中等速度，适合传感器，但需上拉电阻。


