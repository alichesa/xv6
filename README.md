# 硬件
- 半双工是发送器与接收器之间只有一根总线相连接，而全双工是两条总线相连接

- URAT通信协议的中文名称通常为 ​​“通用异步收发传输器”​​（Universal Asynchronous Receiver/Transmitter）。起始-数据-校验-结束
<img width="697" height="250" alt="image" src="https://github.com/user-attachments/assets/42bb30a4-d993-4185-b1f7-f88e2cdcf037" />

- 波特率来进行区分，比如波特率为1，每秒发送1位，那么接收方一秒接收到‘0’，发送的就是01；如果两秒接收到‘0’，那么发送的就是0011

- I2C 使用两条线在主控制器和从机之间进行数据通信，I2C 是支持多从机的，也就是一个 I2C 控制器下可以挂多个 I2C 从设备
<img width="861" height="311" alt="image" src="https://github.com/user-attachments/assets/f17a419d-d770-4af9-85b5-f734d9488135" />

- I2C起始位 -- 时钟为高，数据为低  I2C停止位 -- 时钟和数据都是高

- I2C 总线在数据传输的时候要保证在 SCL 高电平期间， SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生
<img width="951" height="282" alt="image" src="https://github.com/user-attachments/assets/4a8af527-7422-4f21-9e22-9280b5c2583d" />

<img width="956" height="344" alt="image" src="https://github.com/user-attachments/assets/e48e6e80-9177-47b0-aa7f-fc7079c32fc3" />
​​SPI​​：高速、全双工，适合 Flash、ADC 等，但硬件复杂。
​​UART​​：简单、点对点，适合调试，但需固定波特率，仅支持异步通信
USART：不仅支持同步还支持异步，有时钟信号，不需要波特率
​​I2C​​：多设备共享、中等速度，适合传感器，但需上拉电阻。

- RTOS是一种real time os，具有抢占式调度（高优先级任务可以随时抢占低优先级任务的CPU使用权，无需等待低优先级任务主动释放CPU）和时间片调度（相同优先级的任务轮流执行，每个任务分配固定的时间片（如10ms），时间片用完后切换至下一个任务
）

- 优先级：继承是动态提升，天花板是静态预设；天花板优先级需人工设定，继承更自动化

- 柔性数组就是在结构体最后定义的一个空数组，可以在使用结构体的时候动态规划其大小，优点就是与结构体位置紧挨，具有连续内存（更容易被CPU命中）

- 每个进程的页表独立，页表顶端映射内核空间，确保进程切换时内核能够访问必要的数据结构。切换时修改页表基址寄存器，使MMU使用新进程的页表，从而实现内存空间的切换

- 栈指针SP - 用于指向当前栈的位置； 帧指针 - 用于指向当前帧的地址，简单来说就是指向返回地址的位置，用于更加迅速地返回地址

- COW Fork通过让子进程和父进程共享相同的物理内存页，直到其中一个进程尝试修改这些页，从而减少内存复制的开销；子进程的虚拟内存映射与父进程相同，指向相同的物理内存页。此时，子进程和父进程共享这些物理页

- 文件和目录在底层都是数据文件，由索引节点（inode）标识；每个inode包含文件的元数据，如存储位置、大小、类型（目录或文件）等

- 硬链接：多个文件名（目录项）指向同一个数据块，文件内容共享；软链接：新文件名指向原文件的路径，可以跨文件系统，且可以指向不存在的文件。软链接文件可以指向任何文件，包括不存在的文件，而硬链接只能指向已存在的文件，并且硬链接之间不会区分原文件和链接文件

- 锁争用问题的产生原因在于多个CPU同时尝试访问和修改共享的内存管理链表，导致资源竞争和性能下降。等待资源释放的进程内核都是使用自旋的，因为自旋不会进入睡眠状态，随时触发。解决方法就是将内存分片对应，这样就能减少竞争

- 互斥锁的实现基于原子操作、信号量或其他底层机制，确保加锁和解锁操作的原子性和互斥性

- 使用swtch函数进行上下文切换，保存内核线程A的寄存器状态到其上下文，加载调度器线程的上下文，进入调度器函数（scheduler()），寻找可运行的进程B

- 用户空间隔离：每个进程有独立的用户页表，保证进程间内存隔离；内核空间共享：所有进程和内核线程共享同一内核页表，确保内核代码和数据的全局一致性；切换机制：用户态→内核态切换时，CPU 保持内核页表，仅临时加载用户页表副本（如需访问用户内存）‘

- 调用sleep时持有condition lock：在调用sleep函数之前，必须先获取condition lock。这样做的目的是确保sleep函数能够正确地管理锁的状态，防止其他线程或进程在不适当的时候释放锁，导致唤醒失败； 获取p->lock后释放condition lock：在sleep函数中，只有在获取到进程的锁p->lock之后，才能释放condition lock。这样可以确保在睡眠过程中，其他线程或进程无法修改共享资源的状态，从而避免唤醒时的竞态条件； wakeup函数同时持有两个锁：在唤醒一个进程时，必须同时持有condition lock和p->lock。这样可以确保在唤醒过程中，所有相关的锁状态都是正确的，不会出现竞态条件或死锁的情况。

- 锁通常由一个变量来表示，其操作是原子的

- 


