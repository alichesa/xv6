# xv6
- QEMU允许用户在系统上面运行另外一个虚拟系统
- fork调用一次是返回两次，对于父进程是返回子进程的pid，对于子进程是返回0。fork的子进程的描述符会继承父进程的
- exec是从指定的可执行文件中加载程序并替换当前进程的内存镜像，将当前进程的代码和数据替换为另一个程序的内容
- 利用fork和exec可以实现I/O的重定向，因为fork是创建进程，可以先使用close关闭当前的IO，再open文档定义到文档，再使用exec进行替换
- 使用fork和dup可以实现文件的偏移共享
- 管道有两个口，分别用于接收和发送，一个进程可以有多个管道进行通信
- 一个系统中的文件描述符是有限的，fork不仅会创建子进程，还会将父进程的文件描述符传递给子进程
- pipe(fd[2])这就是给当前进程返回两个文件描述符分别指向pipe
- 如果父进程有一个pipe，然后fork了一个子进程，此时的子进程是拥有父进程的pipe副本的，这管道是相通的，可以直接进行通信，这时候就需要关闭某个口才不会出现管道堵塞的问题
- 每个进程都有自己单独的页表
- 内核地址和用户地址是在同一地址空间，只不过有权限隔离，这样方便用户态和内核态的切换。用户态和内核态都有自己的线程，态的切换就是线程是否被挂起
- PC 开机 → 加载 boot loader → boot loader 加载 xv6 内核 → 内核开始运行
- 每个线程都有自己的context，这里面包含了线程结构体的所有信息（寄存器等）
- 创建一个进程： 建页表 → 分内存 → 映射地址 → 拷程序 → 设寄存器 → 就绪调度
- 运行一个进程： 进入调度器 → 找到 RUNNABLE 进程 → 切换到内核线程上下文 → forkret 初始化 → trapret 切换到用户态
- 运行exec：    第一个用户进程（initcode.S）一启动就执行 exec("/init", argv)，用 /init 替代自己，从而启动 shell 等服务，建立用户空间。
- 文件描述符一般是0读1写
- 操作系统就是用来隔离硬件和程序的
- 如果没有操作系统的话，那么就不存在进程的区别，那么都作用于同一片内存，就会容易发生覆盖。操作系统内核会完成不同进程在CPU上的切换
- 
